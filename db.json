{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"source/image/pipe_and_fork/after_close_unused_ends.png","path":"image/pipe_and_fork/after_close_unused_ends.png","modified":0,"renderable":0},{"_id":"source/image/pipe_and_fork/pipe.png","path":"image/pipe_and_fork/pipe.png","modified":0,"renderable":0},{"_id":"source/image/pipe_and_fork/streams.png","path":"image/pipe_and_fork/streams.png","modified":0,"renderable":0},{"_id":"source/image/pipe_and_fork/pipe_and_fork.png","path":"image/pipe_and_fork/pipe_and_fork.png","modified":0,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"51a0353740e01b23d210d94ced3c4302f2b2cd86","modified":1497060512000},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1495114374924},{"_id":"themes/apollo/_config.yml","hash":"65bde17f79cbca07fd41944b528c3abdc556db3b","modified":1497028701000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1495114374924},{"_id":"themes/apollo/README.md","hash":"fb6fbe42172a35cbdaa540a777cc4bc02add2278","modified":1495114374924},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1495114374924},{"_id":"themes/apollo/package.json","hash":"4d13f5f859db7d008f49251543a8f610b2ecabd5","modified":1495114374928},{"_id":"source/_posts/CAP理论.md","hash":"635f490e0cc33b9fbce7db4f296f621a77e919a2","modified":1497683681000},{"_id":"source/_posts/Gossip-Protocal.md","hash":"c15cd272fce8a357ae6ddb5182f691bf0e66ddfa","modified":1495114374924},{"_id":"source/_posts/fork-and-pipe.md","hash":"7d2940b324dbc5d5ca5f6727aaa47a2c111cb629","modified":1495114374924},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1495114374928},{"_id":"themes/apollo/.git/config","hash":"4eba8e6ddc5a8da6c66aa99763c7831c5ddcee6f","modified":1495114374928},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1495114374928},{"_id":"themes/apollo/.git/index","hash":"9b15ee1efb28d0bd801b6f28cce9e56bfb3c9462","modified":1497014179635},{"_id":"themes/apollo/.git/packed-refs","hash":"2ab66d2cb8ce41e703f19a82c8a86fe917b9f9e9","modified":1495114374928},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1495114374932},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1495114374932},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1495114374932},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1495114374932},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1495114374932},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1495114374932},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1495114374932},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1495114374932},{"_id":"source/image/pipe_and_fork/after_close_unused_ends.png","hash":"8bffb19bd425197e6fae93ffc56bd666cc38cd9d","modified":1495114374924},{"_id":"source/image/pipe_and_fork/pipe.png","hash":"ac7deee50833a90206e6bef8a4b37e3a9cbeba09","modified":1495114374924},{"_id":"source/image/pipe_and_fork/streams.png","hash":"1ccfc9ecb4f3dd5d26648c193d0d6a1a7de8357f","modified":1495114374924},{"_id":"source/image/pipe_and_fork/pipe_and_fork.png","hash":"a3aa54ad6aef0bbc2b0b0e5a2be2611cb21b6362","modified":1495114374924},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1495114374928},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1495114374928},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1495114374928},{"_id":"themes/apollo/.git/logs/HEAD","hash":"5948338fa7a06a28f7cec6e9d8ec9e517ad2b40f","modified":1495114374932},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1495114374932},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1495114374932},{"_id":"themes/apollo/layout/partial/head.jade","hash":"d062dafabfe65198e5cf2ddb0e47d909885aa950","modified":1495114374932},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1495114374932},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"dfdd6c667e537a98cca852f713c2057f2012ff61","modified":1495114374932},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"cf3339de8979b5f75a3011f0f6b5451091b77dc8","modified":1497014178903},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1495114374932},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1497014178903},{"_id":"themes/apollo/source/css/apollo.css","hash":"805612fea3f0768dc705058f4b9b8bc95abe4ed4","modified":1495114374932},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1495114374936},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1495114374936},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1495114374936},{"_id":"themes/apollo/.git/objects/pack/pack-bc7754e71bfd2b994957f5f88249124b3b675a21.idx","hash":"dfda7b1ec13babd52c44980f59697775eee31af4","modified":1495114374932},{"_id":"themes/apollo/.git/refs/heads/master","hash":"4605c6681d054db5754369e5211848dd9dcacaef","modified":1495114374928},{"_id":"themes/apollo/.git/objects/e5/ef93d45f775a401617298ed916eed664896d3d","hash":"17eca88e998997d71ee8f5c44da61ae53732c952","modified":1497013939506},{"_id":"themes/apollo/.git/objects/b6/48225a4e8e43d865f36d0b5ea1b13f71b8c44c","hash":"fa1f58b25bd1f5ab13738fa55de154a9ac4dcb0c","modified":1497013939506},{"_id":"themes/apollo/.git/objects/18/526d7edc0bf013c68c3221dabb999725c0d1f7","hash":"1c0873fefcc6f814625876d8aff3ba267f8de612","modified":1497013939506},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"912776a0eb7ad5a387b9aa929c857b6edd0c113e","modified":1495114374936},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1495114374936},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"5948338fa7a06a28f7cec6e9d8ec9e517ad2b40f","modified":1495114374932},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1495114374928},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"5948338fa7a06a28f7cec6e9d8ec9e517ad2b40f","modified":1495114374932},{"_id":"themes/apollo/.git/objects/pack/pack-bc7754e71bfd2b994957f5f88249124b3b675a21.pack","hash":"e7944dc3817acbd44d77922302748b9b659d9446","modified":1495114374932},{"_id":"source/_posts/CAP理论/CAP-Theorem-Example.png","hash":"35d250f23a919d2e4714f1864c7da9ef5920e516","modified":1497683600846},{"_id":"public/2017/06/09/CAP理论/index.html","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1497685567433},{"_id":"public/2016/10/26/Gossip-Protocal/index.html","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1497685567433},{"_id":"public/2016/09/19/fork-and-pipe/index.html","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1497685567434},{"_id":"public/2017/06/09/CAP理论/CAP-Theorem-Example.png","hash":"35d250f23a919d2e4714f1864c7da9ef5920e516","modified":1497685567435}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"CAP理论","date":"2017-06-09T15:47:19.000Z","_content":"### 介绍\nCAP理论指对于一个分布式计算系统来说，不可能同时满足以下三点：\n1. 一致性（Consistence) \n\n    一致性指的是所有节点总是访问到最新的数据，这里的一致性指的是强一致性，即[!Linearizability](http://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf).\n2. 可用性（Availability）\n\n   可用性指对于每一个没有宕机的节点，总是可以返回正确的结果。这里的可用性不同于“高可用”（也就是低宕机时间）。\n    \n3. 分区容错性（Network Partitioning）\n\n   分区容错性指即使发生了网络分区，节点仍然可以响应客户端的请求。  \n\nCAP理论认为分布式系统最多只能CAP中的两点。\n\n![](CAP理论/CAP-Theorem-Example.png)\n\n常见的单机数据库如MYSQL不提供分区容忍，属于AP的系统。\n\n而对于近年来比较火热的NOSQL，设计时更多考虑水平扩展（Scale out），大多提供分区容忍。因而要在一致性和可用性之间做出选择。\n\n以Cassandra和HBase为例，Cassandra的P2P模型提供了良好的水平扩展能力，\n默认提供最终一致性，选择了CAP中的AP。Cassandra也可以配置成强一致性，\n这时就要失去了CAP中的可用性A。\n\n而HBase则是常见的主从架构，牺牲了可用性，选择了CP。\n\n### CAP理论的不足\n\nCAP理论提出以来，得到了计算机理论界的广泛认可。不过也有不少人指出CAP理论的不足之处。\n\nDANIEL ABADI 在他的博文 [Problems with CAP, and Yahoo’s little known NoSQL system](http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html)指出了三点CAP的不足。\n\n1. CP系统表面的定义是支持一致性和分区容错性，没有可用性。但是一直不可用的系统是无用的。应该的定义是只有在发生网络分区时，才牺牲可用性。\n\n2. CA 和 CP是相同的。发生网络分区时，才会有可用性的问题，这个系统是CP的。没有网络分区时，则是可用的（CA）。本质上是同一个系统的两种情况。\n\n3. CAP理论无法描述分布式系统中的另外一个重要属性：延迟（latency)。\n\n\n因此他建议使用 PACELC 来替换 CAP： 如果发生了网络分区（P），可用性（A）和一致性（C）如何选择，或者（E）在正常情况，延迟（L）和一致性（C）如何取舍。\n\nDynamo在发生网络分区时，牺牲了一致性（C），选择了可用性（A）。正常情况下，为了降低延迟（L），放弃了强一致性（C）。所以Dynamo是PA/EL。\n\nMYSQL则始终提供强一致性（C），在某些情况下选择性的放弃了可用性（A）和低延迟（L）。所以MYSQL是PC/EC.\n\n### 参考：\n\n>[CAP_theorem Wiki](https://en.wikipedia.org/wiki/CAP_theorem)\n\n>[Problems with CAP, and Yahoo’s little known NoSQL system](http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html)\n\n>[Please stop calling databases CP or AP](https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)\n\n\n<!-- more -->","source":"_posts/CAP理论.md","raw":"---\ntitle: CAP理论\ndate: 2017-06-09 23:47:19\ntags:\n---\n### 介绍\nCAP理论指对于一个分布式计算系统来说，不可能同时满足以下三点：\n1. 一致性（Consistence) \n\n    一致性指的是所有节点总是访问到最新的数据，这里的一致性指的是强一致性，即[!Linearizability](http://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf).\n2. 可用性（Availability）\n\n   可用性指对于每一个没有宕机的节点，总是可以返回正确的结果。这里的可用性不同于“高可用”（也就是低宕机时间）。\n    \n3. 分区容错性（Network Partitioning）\n\n   分区容错性指即使发生了网络分区，节点仍然可以响应客户端的请求。  \n\nCAP理论认为分布式系统最多只能CAP中的两点。\n\n![](CAP理论/CAP-Theorem-Example.png)\n\n常见的单机数据库如MYSQL不提供分区容忍，属于AP的系统。\n\n而对于近年来比较火热的NOSQL，设计时更多考虑水平扩展（Scale out），大多提供分区容忍。因而要在一致性和可用性之间做出选择。\n\n以Cassandra和HBase为例，Cassandra的P2P模型提供了良好的水平扩展能力，\n默认提供最终一致性，选择了CAP中的AP。Cassandra也可以配置成强一致性，\n这时就要失去了CAP中的可用性A。\n\n而HBase则是常见的主从架构，牺牲了可用性，选择了CP。\n\n### CAP理论的不足\n\nCAP理论提出以来，得到了计算机理论界的广泛认可。不过也有不少人指出CAP理论的不足之处。\n\nDANIEL ABADI 在他的博文 [Problems with CAP, and Yahoo’s little known NoSQL system](http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html)指出了三点CAP的不足。\n\n1. CP系统表面的定义是支持一致性和分区容错性，没有可用性。但是一直不可用的系统是无用的。应该的定义是只有在发生网络分区时，才牺牲可用性。\n\n2. CA 和 CP是相同的。发生网络分区时，才会有可用性的问题，这个系统是CP的。没有网络分区时，则是可用的（CA）。本质上是同一个系统的两种情况。\n\n3. CAP理论无法描述分布式系统中的另外一个重要属性：延迟（latency)。\n\n\n因此他建议使用 PACELC 来替换 CAP： 如果发生了网络分区（P），可用性（A）和一致性（C）如何选择，或者（E）在正常情况，延迟（L）和一致性（C）如何取舍。\n\nDynamo在发生网络分区时，牺牲了一致性（C），选择了可用性（A）。正常情况下，为了降低延迟（L），放弃了强一致性（C）。所以Dynamo是PA/EL。\n\nMYSQL则始终提供强一致性（C），在某些情况下选择性的放弃了可用性（A）和低延迟（L）。所以MYSQL是PC/EC.\n\n### 参考：\n\n>[CAP_theorem Wiki](https://en.wikipedia.org/wiki/CAP_theorem)\n\n>[Problems with CAP, and Yahoo’s little known NoSQL system](http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html)\n\n>[Please stop calling databases CP or AP](https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)\n\n\n<!-- more -->","slug":"CAP理论","published":1,"updated":"2017-06-17T07:14:41.000Z","_id":"cj40xzpal0000inxxot9pjtef","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>CAP理论指对于一个分布式计算系统来说，不可能同时满足以下三点：</p>\n<ol>\n<li><p>一致性（Consistence) </p>\n<p> 一致性指的是所有节点总是访问到最新的数据，这里的一致性指的是强一致性，即<a href=\"http://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf\" target=\"_blank\" rel=\"external\">!Linearizability</a>.</p>\n</li>\n<li><p>可用性（Availability）</p>\n<p>可用性指对于每一个没有宕机的节点，总是可以返回正确的结果。这里的可用性不同于“高可用”（也就是低宕机时间）。</p>\n</li>\n<li><p>分区容错性（Network Partitioning）</p>\n<p>分区容错性指即使发生了网络分区，节点仍然可以响应客户端的请求。  </p>\n</li>\n</ol>\n<p>CAP理论认为分布式系统最多只能CAP中的两点。</p>\n<p><img src=\"CAP理论/CAP-Theorem-Example.png\" alt=\"\"></p>\n<p>常见的单机数据库如MYSQL不提供分区容忍，属于AP的系统。</p>\n<p>而对于近年来比较火热的NOSQL，设计时更多考虑水平扩展（Scale out），大多提供分区容忍。因而要在一致性和可用性之间做出选择。</p>\n<p>以Cassandra和HBase为例，Cassandra的P2P模型提供了良好的水平扩展能力，<br>默认提供最终一致性，选择了CAP中的AP。Cassandra也可以配置成强一致性，<br>这时就要失去了CAP中的可用性A。</p>\n<p>而HBase则是常见的主从架构，牺牲了可用性，选择了CP。</p>\n<h3 id=\"CAP理论的不足\"><a href=\"#CAP理论的不足\" class=\"headerlink\" title=\"CAP理论的不足\"></a>CAP理论的不足</h3><p>CAP理论提出以来，得到了计算机理论界的广泛认可。不过也有不少人指出CAP理论的不足之处。</p>\n<p>DANIEL ABADI 在他的博文 <a href=\"http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html\" target=\"_blank\" rel=\"external\">Problems with CAP, and Yahoo’s little known NoSQL system</a>指出了三点CAP的不足。</p>\n<ol>\n<li><p>CP系统表面的定义是支持一致性和分区容错性，没有可用性。但是一直不可用的系统是无用的。应该的定义是只有在发生网络分区时，才牺牲可用性。</p>\n</li>\n<li><p>CA 和 CP是相同的。发生网络分区时，才会有可用性的问题，这个系统是CP的。没有网络分区时，则是可用的（CA）。本质上是同一个系统的两种情况。</p>\n</li>\n<li><p>CAP理论无法描述分布式系统中的另外一个重要属性：延迟（latency)。</p>\n</li>\n</ol>\n<p>因此他建议使用 PACELC 来替换 CAP： 如果发生了网络分区（P），可用性（A）和一致性（C）如何选择，或者（E）在正常情况，延迟（L）和一致性（C）如何取舍。</p>\n<p>Dynamo在发生网络分区时，牺牲了一致性（C），选择了可用性（A）。正常情况下，为了降低延迟（L），放弃了强一致性（C）。所以Dynamo是PA/EL。</p>\n<p>MYSQL则始终提供强一致性（C），在某些情况下选择性的放弃了可用性（A）和低延迟（L）。所以MYSQL是PC/EC.</p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/CAP_theorem\" target=\"_blank\" rel=\"external\">CAP_theorem Wiki</a></p>\n<p><a href=\"http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html\" target=\"_blank\" rel=\"external\">Problems with CAP, and Yahoo’s little known NoSQL system</a></p>\n<p><a href=\"https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"external\">Please stop calling databases CP or AP</a></p>\n</blockquote>\n<a id=\"more\"></a>","excerpt":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>CAP理论指对于一个分布式计算系统来说，不可能同时满足以下三点：</p>\n<ol>\n<li><p>一致性（Consistence) </p>\n<p> 一致性指的是所有节点总是访问到最新的数据，这里的一致性指的是强一致性，即<a href=\"http://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf\">!Linearizability</a>.</p>\n</li>\n<li><p>可用性（Availability）</p>\n<p>可用性指对于每一个没有宕机的节点，总是可以返回正确的结果。这里的可用性不同于“高可用”（也就是低宕机时间）。</p>\n</li>\n<li><p>分区容错性（Network Partitioning）</p>\n<p>分区容错性指即使发生了网络分区，节点仍然可以响应客户端的请求。  </p>\n</li>\n</ol>\n<p>CAP理论认为分布式系统最多只能CAP中的两点。</p>\n<p><img src=\"CAP理论/CAP-Theorem-Example.png\" alt=\"\"></p>\n<p>常见的单机数据库如MYSQL不提供分区容忍，属于AP的系统。</p>\n<p>而对于近年来比较火热的NOSQL，设计时更多考虑水平扩展（Scale out），大多提供分区容忍。因而要在一致性和可用性之间做出选择。</p>\n<p>以Cassandra和HBase为例，Cassandra的P2P模型提供了良好的水平扩展能力，<br>默认提供最终一致性，选择了CAP中的AP。Cassandra也可以配置成强一致性，<br>这时就要失去了CAP中的可用性A。</p>\n<p>而HBase则是常见的主从架构，牺牲了可用性，选择了CP。</p>\n<h3 id=\"CAP理论的不足\"><a href=\"#CAP理论的不足\" class=\"headerlink\" title=\"CAP理论的不足\"></a>CAP理论的不足</h3><p>CAP理论提出以来，得到了计算机理论界的广泛认可。不过也有不少人指出CAP理论的不足之处。</p>\n<p>DANIEL ABADI 在他的博文 <a href=\"http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html\">Problems with CAP, and Yahoo’s little known NoSQL system</a>指出了三点CAP的不足。</p>\n<ol>\n<li><p>CP系统表面的定义是支持一致性和分区容错性，没有可用性。但是一直不可用的系统是无用的。应该的定义是只有在发生网络分区时，才牺牲可用性。</p>\n</li>\n<li><p>CA 和 CP是相同的。发生网络分区时，才会有可用性的问题，这个系统是CP的。没有网络分区时，则是可用的（CA）。本质上是同一个系统的两种情况。</p>\n</li>\n<li><p>CAP理论无法描述分布式系统中的另外一个重要属性：延迟（latency)。</p>\n</li>\n</ol>\n<p>因此他建议使用 PACELC 来替换 CAP： 如果发生了网络分区（P），可用性（A）和一致性（C）如何选择，或者（E）在正常情况，延迟（L）和一致性（C）如何取舍。</p>\n<p>Dynamo在发生网络分区时，牺牲了一致性（C），选择了可用性（A）。正常情况下，为了降低延迟（L），放弃了强一致性（C）。所以Dynamo是PA/EL。</p>\n<p>MYSQL则始终提供强一致性（C），在某些情况下选择性的放弃了可用性（A）和低延迟（L）。所以MYSQL是PC/EC.</p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/CAP_theorem\">CAP_theorem Wiki</a></p>\n<p><a href=\"http://dbmsmusings.blogspot.co.il/2010/04/problems-with-cap-and-yahoos-little.html\">Problems with CAP, and Yahoo’s little known NoSQL system</a></p>\n<p><a href=\"https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\">Please stop calling databases CP or AP</a></p>\n</blockquote>","more":""},{"title":"Gossip Protocal","date":"2016-10-26T13:23:51.000Z","_content":"#### 什么是Gossip协议\nGossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。\n\n#### Epidemiology\n流行病传染最基本的模型仅作如下几个假设：\n\n1. (n+1)个人均匀的分布在一起\n2. 每一对人群之间的传染概率是$\\beta$，显然$0<\\beta<1$.\n3. 任意时刻，某个人要么处于infected的状态要么处于uninfected的状态.\n4. 一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。\n\n有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y\\_t$，处于uninfected状态的人为$x\\_t$，那么初始状态 $y\\_0=1$, $x\\_0=n$，并且在任何时候$x\\_t+y\\_t=n+1$.\n\n考虑连续的时间，可知：\n\n>$\\frac{dx}{dt}=−βxy$\n\n解为：\n\n>$x=\\frac{n(n+1)}{n+e^{β(n+1)t}}$\n$y=\\frac{n+1}{1+ne^{−β(n+1)t}}$\n\n明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。\n\n如果每个人每次传染的人数是b,那么\n>$\\beta=\\frac{b}{n}$\n\n令 t=$clog(n)$,可以得到 $y\\approx(n+1)-\\frac{1}{n^{cb-2}}$\n\n这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:\n\n1. 低延迟。仅仅需要$O(log(n))$个回合的传递时间。\n2. 非常可靠。仅有$\\frac{1}{n^{cb-2}}$个节点不会收到信息。\n3. 轻量级。每个节点传送了$cblog(n)$次信息。\n\n于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。\n\n#### Gossip节点的通信方式\n根据原论文，两个节点（A、B）之间存在三种通信方式:\n\n* push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据\n* pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地\n* push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地\n\n如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。\n\n假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P\\_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:\n>$P\\_{i+1}=P\\_i^{b+1}$\n\n而push为：\n>$P\\_{i+1}=P\\_i(1-\\frac{1}{n})^{n(1-P\\_i)}$\n\n显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0<p<1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。\n\n<!-- more -->\n","source":"_posts/Gossip-Protocal.md","raw":"---\ntitle: Gossip Protocal\ndate: 2016-10-26 21:23:51\n\n---\n#### 什么是Gossip协议\nGossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。\n\n#### Epidemiology\n流行病传染最基本的模型仅作如下几个假设：\n\n1. (n+1)个人均匀的分布在一起\n2. 每一对人群之间的传染概率是$\\beta$，显然$0<\\beta<1$.\n3. 任意时刻，某个人要么处于infected的状态要么处于uninfected的状态.\n4. 一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。\n\n有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y\\_t$，处于uninfected状态的人为$x\\_t$，那么初始状态 $y\\_0=1$, $x\\_0=n$，并且在任何时候$x\\_t+y\\_t=n+1$.\n\n考虑连续的时间，可知：\n\n>$\\frac{dx}{dt}=−βxy$\n\n解为：\n\n>$x=\\frac{n(n+1)}{n+e^{β(n+1)t}}$\n$y=\\frac{n+1}{1+ne^{−β(n+1)t}}$\n\n明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。\n\n如果每个人每次传染的人数是b,那么\n>$\\beta=\\frac{b}{n}$\n\n令 t=$clog(n)$,可以得到 $y\\approx(n+1)-\\frac{1}{n^{cb-2}}$\n\n这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:\n\n1. 低延迟。仅仅需要$O(log(n))$个回合的传递时间。\n2. 非常可靠。仅有$\\frac{1}{n^{cb-2}}$个节点不会收到信息。\n3. 轻量级。每个节点传送了$cblog(n)$次信息。\n\n于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。\n\n#### Gossip节点的通信方式\n根据原论文，两个节点（A、B）之间存在三种通信方式:\n\n* push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据\n* pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地\n* push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地\n\n如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。\n\n假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P\\_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:\n>$P\\_{i+1}=P\\_i^{b+1}$\n\n而push为：\n>$P\\_{i+1}=P\\_i(1-\\frac{1}{n})^{n(1-P\\_i)}$\n\n显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0<p<1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。\n\n<!-- more -->\n","slug":"Gossip-Protocal","published":1,"updated":"2017-05-18T13:32:54.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj40xzpau0001inxxf7k8fped","content":"<h4 id=\"什么是Gossip协议\"><a href=\"#什么是Gossip协议\" class=\"headerlink\" title=\"什么是Gossip协议\"></a>什么是Gossip协议</h4><p>Gossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。</p>\n<h4 id=\"Epidemiology\"><a href=\"#Epidemiology\" class=\"headerlink\" title=\"Epidemiology\"></a>Epidemiology</h4><p>流行病传染最基本的模型仅作如下几个假设：</p>\n<ol>\n<li>(n+1)个人均匀的分布在一起</li>\n<li>每一对人群之间的传染概率是$\\beta$，显然$0&lt;\\beta&lt;1$.</li>\n<li>任意时刻，某个人要么处于infected的状态要么处于uninfected的状态.</li>\n<li>一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。</li>\n</ol>\n<p>有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y_t$，处于uninfected状态的人为$x_t$，那么初始状态 $y_0=1$, $x_0=n$，并且在任何时候$x_t+y_t=n+1$.</p>\n<p>考虑连续的时间，可知：</p>\n<blockquote>\n<p>$\\frac{dx}{dt}=−βxy$</p>\n</blockquote>\n<p>解为：</p>\n<blockquote>\n<p>$x=\\frac{n(n+1)}{n+e^{β(n+1)t}}$<br>$y=\\frac{n+1}{1+ne^{−β(n+1)t}}$</p>\n</blockquote>\n<p>明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。</p>\n<p>如果每个人每次传染的人数是b,那么</p>\n<blockquote>\n<p>$\\beta=\\frac{b}{n}$</p>\n</blockquote>\n<p>令 t=$clog(n)$,可以得到 $y\\approx(n+1)-\\frac{1}{n^{cb-2}}$</p>\n<p>这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:</p>\n<ol>\n<li>低延迟。仅仅需要$O(log(n))$个回合的传递时间。</li>\n<li>非常可靠。仅有$\\frac{1}{n^{cb-2}}$个节点不会收到信息。</li>\n<li>轻量级。每个节点传送了$cblog(n)$次信息。</li>\n</ol>\n<p>于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。</p>\n<h4 id=\"Gossip节点的通信方式\"><a href=\"#Gossip节点的通信方式\" class=\"headerlink\" title=\"Gossip节点的通信方式\"></a>Gossip节点的通信方式</h4><p>根据原论文，两个节点（A、B）之间存在三种通信方式:</p>\n<ul>\n<li>push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据</li>\n<li>pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地</li>\n<li>push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地</li>\n</ul>\n<p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。</p>\n<p>假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:</p>\n<blockquote>\n<p>$P_{i+1}=P_i^{b+1}$</p>\n</blockquote>\n<p>而push为：</p>\n<blockquote>\n<p>$P_{i+1}=P_i(1-\\frac{1}{n})^{n(1-P_i)}$</p>\n</blockquote>\n<p>显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0&lt;p&lt;1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。</p>\n<a id=\"more\"></a>\n","excerpt":"<h4 id=\"什么是Gossip协议\"><a href=\"#什么是Gossip协议\" class=\"headerlink\" title=\"什么是Gossip协议\"></a>什么是Gossip协议</h4><p>Gossip Protocol利用一种随机的方式将信息散播到整个网络中。正如Gossip本身的含义一样，Gossip协议的工作流程即类似于绯闻的传播，或者流行病的传播。</p>\n<h4 id=\"Epidemiology\"><a href=\"#Epidemiology\" class=\"headerlink\" title=\"Epidemiology\"></a>Epidemiology</h4><p>流行病传染最基本的模型仅作如下几个假设：</p>\n<ol>\n<li>(n+1)个人均匀的分布在一起</li>\n<li>每一对人群之间的传染概率是$\\beta$，显然$0&lt;\\beta&lt;1$.</li>\n<li>任意时刻，某个人要么处于infected的状态要么处于uninfected的状态.</li>\n<li>一旦某个人从uninfected状态转变成为infected状态，其一直停留在infected状态。</li>\n</ol>\n<p>有了以上假设，我们可以进一步分析流行病的传染情况。我们记t时刻处于infected状态的人数为$y_t$，处于uninfected状态的人为$x_t$，那么初始状态 $y_0=1$, $x_0=n$，并且在任何时候$x_t+y_t=n+1$.</p>\n<p>考虑连续的时间，可知：</p>\n<blockquote>\n<p>$\\frac{dx}{dt}=−βxy$</p>\n</blockquote>\n<p>解为：</p>\n<blockquote>\n<p>$x=\\frac{n(n+1)}{n+e^{β(n+1)t}}$<br>$y=\\frac{n+1}{1+ne^{−β(n+1)t}}$</p>\n</blockquote>\n<p>明显，当$t→∞$时，$x→0,y→(n+1)x→0,y→(n+1)$，即经过足够的时间，所有的人都将被传染。</p>\n<p>如果每个人每次传染的人数是b,那么</p>\n<blockquote>\n<p>$\\beta=\\frac{b}{n}$</p>\n</blockquote>\n<p>令 t=$clog(n)$,可以得到 $y\\approx(n+1)-\\frac{1}{n^{cb-2}}$</p>\n<p>这表明，仅需要$O(log(n))$个回合，gossip协议即可将信息传递到所有的节点。 根据分析可得，Gossip协议具有以下的特点:</p>\n<ol>\n<li>低延迟。仅仅需要$O(log(n))$个回合的传递时间。</li>\n<li>非常可靠。仅有$\\frac{1}{n^{cb-2}}$个节点不会收到信息。</li>\n<li>轻量级。每个节点传送了$cblog(n)$次信息。</li>\n</ol>\n<p>于此同时，Gossip协议的容错性比较高，例如，50的丢包率等价于使用b/2b带代替b进行分析；50的节点错误等价于使用n/2来代替nn，同时使用b/2来代替b进行分析，其分析结果不用带来数量级上的变化。</p>\n<h4 id=\"Gossip节点的通信方式\"><a href=\"#Gossip节点的通信方式\" class=\"headerlink\" title=\"Gossip节点的通信方式\"></a>Gossip节点的通信方式</h4><p>根据原论文，两个节点（A、B）之间存在三种通信方式:</p>\n<ul>\n<li>push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据</li>\n<li>pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地</li>\n<li>push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地</li>\n</ul>\n<p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。</p>\n<p>假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(log(n))$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第$i$个周期被感染的概率为$P_i$ ,第$i+1$个周期被感染的概率为$P^{i+1}$ ，则pull的方式:</p>\n<blockquote>\n<p>$P_{i+1}=P_i^{b+1}$</p>\n</blockquote>\n<p>而push为：</p>\n<blockquote>\n<p>$P_{i+1}=P_i(1-\\frac{1}{n})^{n(1-P_i)}$</p>\n</blockquote>\n<p>显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0&lt;p&lt;1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。</p>","more":""},{"title":"pipe and fork","date":"2016-09-19T14:51:09.000Z","_content":"\n## Pipe Introduction\n\nEvery program we run on the command line automatically has three data streams connected to it.\n\nSTDIN (0) - Standard input (data fed into the program)\nSTDOUT (1) - Standard output (data printed by the program, defaults to the terminal)\nSTDERR (2) - Standard error (for error messages, also defaults to the terminal)\n\n![streams](/image/pipe_and_fork/streams.png)\n\n## Create a simple pipe in C\n\nTo create a simple pipe with C, we make use of the pipe() system call. It takes a single argument, which is an array of two integers, and if successful, the array will contain two new file descriptors to be used for the pipeline. After creating a pipe, the process typically spawns a new process (remember the child inherits open file descriptors).\n\n  >SYSTEM CALL: pipe();                                                          \n  >\n  PROTOTYPE: int pipe( int fd[2] );                                             \n    RETURNS: 0 on success                                                       \n             -1 on error: errno = EMFILE (no free descriptors)                  \n                                  EMFILE (system file table is full)            \n                                  EFAULT (fd array is not valid)                \n\nNOTES: fd[0] is set up for reading, fd[1] is set up for writing\n\ncode example:\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nmain()\n{\n    int     fd[2];\n    pid_t   childpid;\n\n    pipe(fd);\n    .\n    .\n}\n```\n\nAfter pipe is invoked, fd[0] and fd[1] are connected as following picture.\n\n![pipe](/image/pipe_and_fork/pipe.png)\n\n<!-- more -->\n### Use fork and pipe\n\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nmain()\n{\n        int     fd[2];\n        pid_t   childpid;\n\n        pipe(fd);\n\n        if((childpid = fork()) == -1)\n        {\n                perror(\"fork\");\n                exit(1);\n        }\n\n        if(childpid == 0)\n        {\n                /* Child process closes up input side of pipe */\n                close(fd[0]);\n        }\n        else\n        {\n                /* Parent process closes up output side of pipe */\n                close(fd[1]);\n        }\n        .\n        .\n}\n```\n\nAfter fork is called, child process is created and it also have the two file descriptors.\n\n![pipe_and_fork](/image/pipe_and_fork/pipe_and_fork.png)\n\nIf the parent wants to receive data from the child, it should close fd1, and the child should close fd0. If the parent wants to send data to the child, it should close fd0, and the child should close fd1. Since descriptors are shared between the parent and child, we should always be sure to close the end of pipe we aren't concerned with. On a technical note, the EOF will never be returned if the unnecessary ends of the pipe are not explicitly closed.\n\n![pipe_and_fork](/image/pipe_and_fork/after_close_unused_ends.png)\n\n\n\n Once the pipeline has been established, the file descriptors may be treated like descriptors to normal files.\n\n```\n/*****************************************************************************\n Excerpt from \"Linux Programmer's Guide - Chapter 6\"\n (C)opyright 1994-1995, Scott Burkett\n *****************************************************************************\n MODULE: pipe.c\n *****************************************************************************/\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint main(void)\n{\n        int     fd[2], nbytes;\n        pid_t   childpid;\n        char    string[] = \"Hello, world!\\n\";\n        char    readbuffer[80];\n\n        pipe(fd);\n\n        if((childpid = fork()) == -1)\n        {\n                perror(\"fork\");\n                exit(1);\n        }\n\n        if(childpid == 0)\n        {\n                /* Child process closes up input side of pipe */\n                close(fd[0]);\n\n                /* Send \"string\" through the output side of pipe */\n                write(fd[1], string, (strlen(string)+1));\n                exit(0);\n        }\n        else\n        {\n                /* Parent process closes up output side of pipe */\n                close(fd[1]);\n\n                /* Read in a string from the pipe */\n                nbytes = read(fd[0], readbuffer, sizeof(readbuffer));\n                printf(\"Received string: %s\", readbuffer);\n        }\n\n        return(0);\n}\n```\n\n\n### Reference:\n* http://tldp.org/LDP/lpg/node11.html\n* https://upsilon.cc/~zack/teaching/1314/progsyst/cours-03-pipe.pdf\n","source":"_posts/fork-and-pipe.md","raw":"---\ntitle: pipe and fork\ndate: 2016-09-19 22:51:09\n\n---\n\n## Pipe Introduction\n\nEvery program we run on the command line automatically has three data streams connected to it.\n\nSTDIN (0) - Standard input (data fed into the program)\nSTDOUT (1) - Standard output (data printed by the program, defaults to the terminal)\nSTDERR (2) - Standard error (for error messages, also defaults to the terminal)\n\n![streams](/image/pipe_and_fork/streams.png)\n\n## Create a simple pipe in C\n\nTo create a simple pipe with C, we make use of the pipe() system call. It takes a single argument, which is an array of two integers, and if successful, the array will contain two new file descriptors to be used for the pipeline. After creating a pipe, the process typically spawns a new process (remember the child inherits open file descriptors).\n\n  >SYSTEM CALL: pipe();                                                          \n  >\n  PROTOTYPE: int pipe( int fd[2] );                                             \n    RETURNS: 0 on success                                                       \n             -1 on error: errno = EMFILE (no free descriptors)                  \n                                  EMFILE (system file table is full)            \n                                  EFAULT (fd array is not valid)                \n\nNOTES: fd[0] is set up for reading, fd[1] is set up for writing\n\ncode example:\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nmain()\n{\n    int     fd[2];\n    pid_t   childpid;\n\n    pipe(fd);\n    .\n    .\n}\n```\n\nAfter pipe is invoked, fd[0] and fd[1] are connected as following picture.\n\n![pipe](/image/pipe_and_fork/pipe.png)\n\n<!-- more -->\n### Use fork and pipe\n\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nmain()\n{\n        int     fd[2];\n        pid_t   childpid;\n\n        pipe(fd);\n\n        if((childpid = fork()) == -1)\n        {\n                perror(\"fork\");\n                exit(1);\n        }\n\n        if(childpid == 0)\n        {\n                /* Child process closes up input side of pipe */\n                close(fd[0]);\n        }\n        else\n        {\n                /* Parent process closes up output side of pipe */\n                close(fd[1]);\n        }\n        .\n        .\n}\n```\n\nAfter fork is called, child process is created and it also have the two file descriptors.\n\n![pipe_and_fork](/image/pipe_and_fork/pipe_and_fork.png)\n\nIf the parent wants to receive data from the child, it should close fd1, and the child should close fd0. If the parent wants to send data to the child, it should close fd0, and the child should close fd1. Since descriptors are shared between the parent and child, we should always be sure to close the end of pipe we aren't concerned with. On a technical note, the EOF will never be returned if the unnecessary ends of the pipe are not explicitly closed.\n\n![pipe_and_fork](/image/pipe_and_fork/after_close_unused_ends.png)\n\n\n\n Once the pipeline has been established, the file descriptors may be treated like descriptors to normal files.\n\n```\n/*****************************************************************************\n Excerpt from \"Linux Programmer's Guide - Chapter 6\"\n (C)opyright 1994-1995, Scott Burkett\n *****************************************************************************\n MODULE: pipe.c\n *****************************************************************************/\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nint main(void)\n{\n        int     fd[2], nbytes;\n        pid_t   childpid;\n        char    string[] = \"Hello, world!\\n\";\n        char    readbuffer[80];\n\n        pipe(fd);\n\n        if((childpid = fork()) == -1)\n        {\n                perror(\"fork\");\n                exit(1);\n        }\n\n        if(childpid == 0)\n        {\n                /* Child process closes up input side of pipe */\n                close(fd[0]);\n\n                /* Send \"string\" through the output side of pipe */\n                write(fd[1], string, (strlen(string)+1));\n                exit(0);\n        }\n        else\n        {\n                /* Parent process closes up output side of pipe */\n                close(fd[1]);\n\n                /* Read in a string from the pipe */\n                nbytes = read(fd[0], readbuffer, sizeof(readbuffer));\n                printf(\"Received string: %s\", readbuffer);\n        }\n\n        return(0);\n}\n```\n\n\n### Reference:\n* http://tldp.org/LDP/lpg/node11.html\n* https://upsilon.cc/~zack/teaching/1314/progsyst/cours-03-pipe.pdf\n","slug":"fork-and-pipe","published":1,"updated":"2017-05-18T13:32:54.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj40xzpaz0002inxx2r8szo29","content":"<h2 id=\"Pipe-Introduction\"><a href=\"#Pipe-Introduction\" class=\"headerlink\" title=\"Pipe Introduction\"></a>Pipe Introduction</h2><p>Every program we run on the command line automatically has three data streams connected to it.</p>\n<p>STDIN (0) - Standard input (data fed into the program)<br>STDOUT (1) - Standard output (data printed by the program, defaults to the terminal)<br>STDERR (2) - Standard error (for error messages, also defaults to the terminal)</p>\n<p><img src=\"/image/pipe_and_fork/streams.png\" alt=\"streams\"></p>\n<h2 id=\"Create-a-simple-pipe-in-C\"><a href=\"#Create-a-simple-pipe-in-C\" class=\"headerlink\" title=\"Create a simple pipe in C\"></a>Create a simple pipe in C</h2><p>To create a simple pipe with C, we make use of the pipe() system call. It takes a single argument, which is an array of two integers, and if successful, the array will contain two new file descriptors to be used for the pipeline. After creating a pipe, the process typically spawns a new process (remember the child inherits open file descriptors).</p>\n<blockquote>\n<p>SYSTEM CALL: pipe();                                                          </p>\n<p>  PROTOTYPE: int pipe( int fd[2] );<br>    RETURNS: 0 on success<br>             -1 on error: errno = EMFILE (no free descriptors)<br>                                  EMFILE (system file table is full)<br>                                  EFAULT (fd array is not valid)                </p>\n</blockquote>\n<p>NOTES: fd[0] is set up for reading, fd[1] is set up for writing</p>\n<p>code example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;sys/types.h&gt;</div><div class=\"line\"></div><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int     fd[2];</div><div class=\"line\">    pid_t   childpid;</div><div class=\"line\"></div><div class=\"line\">    pipe(fd);</div><div class=\"line\">    .</div><div class=\"line\">    .</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>After pipe is invoked, fd[0] and fd[1] are connected as following picture.</p>\n<p><img src=\"/image/pipe_and_fork/pipe.png\" alt=\"pipe\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Use-fork-and-pipe\"><a href=\"#Use-fork-and-pipe\" class=\"headerlink\" title=\"Use fork and pipe\"></a>Use fork and pipe</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;sys/types.h&gt;</div><div class=\"line\"></div><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">        int     fd[2];</div><div class=\"line\">        pid_t   childpid;</div><div class=\"line\"></div><div class=\"line\">        pipe(fd);</div><div class=\"line\"></div><div class=\"line\">        if((childpid = fork()) == -1)</div><div class=\"line\">        &#123;</div><div class=\"line\">                perror(&quot;fork&quot;);</div><div class=\"line\">                exit(1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(childpid == 0)</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Child process closes up input side of pipe */</div><div class=\"line\">                close(fd[0]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Parent process closes up output side of pipe */</div><div class=\"line\">                close(fd[1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        .</div><div class=\"line\">        .</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>After fork is called, child process is created and it also have the two file descriptors.</p>\n<p><img src=\"/image/pipe_and_fork/pipe_and_fork.png\" alt=\"pipe_and_fork\"></p>\n<p>If the parent wants to receive data from the child, it should close fd1, and the child should close fd0. If the parent wants to send data to the child, it should close fd0, and the child should close fd1. Since descriptors are shared between the parent and child, we should always be sure to close the end of pipe we aren’t concerned with. On a technical note, the EOF will never be returned if the unnecessary ends of the pipe are not explicitly closed.</p>\n<p><img src=\"/image/pipe_and_fork/after_close_unused_ends.png\" alt=\"pipe_and_fork\"></p>\n<p> Once the pipeline has been established, the file descriptors may be treated like descriptors to normal files.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*****************************************************************************</div><div class=\"line\"> Excerpt from &quot;Linux Programmer&apos;s Guide - Chapter 6&quot;</div><div class=\"line\"> (C)opyright 1994-1995, Scott Burkett</div><div class=\"line\"> *****************************************************************************</div><div class=\"line\"> MODULE: pipe.c</div><div class=\"line\"> *****************************************************************************/</div><div class=\"line\"></div><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;sys/types.h&gt;</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">        int     fd[2], nbytes;</div><div class=\"line\">        pid_t   childpid;</div><div class=\"line\">        char    string[] = &quot;Hello, world!\\n&quot;;</div><div class=\"line\">        char    readbuffer[80];</div><div class=\"line\"></div><div class=\"line\">        pipe(fd);</div><div class=\"line\"></div><div class=\"line\">        if((childpid = fork()) == -1)</div><div class=\"line\">        &#123;</div><div class=\"line\">                perror(&quot;fork&quot;);</div><div class=\"line\">                exit(1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(childpid == 0)</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Child process closes up input side of pipe */</div><div class=\"line\">                close(fd[0]);</div><div class=\"line\"></div><div class=\"line\">                /* Send &quot;string&quot; through the output side of pipe */</div><div class=\"line\">                write(fd[1], string, (strlen(string)+1));</div><div class=\"line\">                exit(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Parent process closes up output side of pipe */</div><div class=\"line\">                close(fd[1]);</div><div class=\"line\"></div><div class=\"line\">                /* Read in a string from the pipe */</div><div class=\"line\">                nbytes = read(fd[0], readbuffer, sizeof(readbuffer));</div><div class=\"line\">                printf(&quot;Received string: %s&quot;, readbuffer);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference:\"></a>Reference:</h3><ul>\n<li><a href=\"http://tldp.org/LDP/lpg/node11.html\" target=\"_blank\" rel=\"external\">http://tldp.org/LDP/lpg/node11.html</a></li>\n<li><a href=\"https://upsilon.cc/~zack/teaching/1314/progsyst/cours-03-pipe.pdf\" target=\"_blank\" rel=\"external\">https://upsilon.cc/~zack/teaching/1314/progsyst/cours-03-pipe.pdf</a></li>\n</ul>\n","excerpt":"<h2 id=\"Pipe-Introduction\"><a href=\"#Pipe-Introduction\" class=\"headerlink\" title=\"Pipe Introduction\"></a>Pipe Introduction</h2><p>Every program we run on the command line automatically has three data streams connected to it.</p>\n<p>STDIN (0) - Standard input (data fed into the program)<br>STDOUT (1) - Standard output (data printed by the program, defaults to the terminal)<br>STDERR (2) - Standard error (for error messages, also defaults to the terminal)</p>\n<p><img src=\"/image/pipe_and_fork/streams.png\" alt=\"streams\"></p>\n<h2 id=\"Create-a-simple-pipe-in-C\"><a href=\"#Create-a-simple-pipe-in-C\" class=\"headerlink\" title=\"Create a simple pipe in C\"></a>Create a simple pipe in C</h2><p>To create a simple pipe with C, we make use of the pipe() system call. It takes a single argument, which is an array of two integers, and if successful, the array will contain two new file descriptors to be used for the pipeline. After creating a pipe, the process typically spawns a new process (remember the child inherits open file descriptors).</p>\n<blockquote>\n<p>SYSTEM CALL: pipe();                                                          </p>\n<p>  PROTOTYPE: int pipe( int fd[2] );<br>    RETURNS: 0 on success<br>             -1 on error: errno = EMFILE (no free descriptors)<br>                                  EMFILE (system file table is full)<br>                                  EFAULT (fd array is not valid)                </p>\n</blockquote>\n<p>NOTES: fd[0] is set up for reading, fd[1] is set up for writing</p>\n<p>code example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;sys/types.h&gt;</div><div class=\"line\"></div><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int     fd[2];</div><div class=\"line\">    pid_t   childpid;</div><div class=\"line\"></div><div class=\"line\">    pipe(fd);</div><div class=\"line\">    .</div><div class=\"line\">    .</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>After pipe is invoked, fd[0] and fd[1] are connected as following picture.</p>\n<p><img src=\"/image/pipe_and_fork/pipe.png\" alt=\"pipe\"></p>","more":"<h3 id=\"Use-fork-and-pipe\"><a href=\"#Use-fork-and-pipe\" class=\"headerlink\" title=\"Use fork and pipe\"></a>Use fork and pipe</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;sys/types.h&gt;</div><div class=\"line\"></div><div class=\"line\">main()</div><div class=\"line\">&#123;</div><div class=\"line\">        int     fd[2];</div><div class=\"line\">        pid_t   childpid;</div><div class=\"line\"></div><div class=\"line\">        pipe(fd);</div><div class=\"line\"></div><div class=\"line\">        if((childpid = fork()) == -1)</div><div class=\"line\">        &#123;</div><div class=\"line\">                perror(&quot;fork&quot;);</div><div class=\"line\">                exit(1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(childpid == 0)</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Child process closes up input side of pipe */</div><div class=\"line\">                close(fd[0]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Parent process closes up output side of pipe */</div><div class=\"line\">                close(fd[1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        .</div><div class=\"line\">        .</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>After fork is called, child process is created and it also have the two file descriptors.</p>\n<p><img src=\"/image/pipe_and_fork/pipe_and_fork.png\" alt=\"pipe_and_fork\"></p>\n<p>If the parent wants to receive data from the child, it should close fd1, and the child should close fd0. If the parent wants to send data to the child, it should close fd0, and the child should close fd1. Since descriptors are shared between the parent and child, we should always be sure to close the end of pipe we aren’t concerned with. On a technical note, the EOF will never be returned if the unnecessary ends of the pipe are not explicitly closed.</p>\n<p><img src=\"/image/pipe_and_fork/after_close_unused_ends.png\" alt=\"pipe_and_fork\"></p>\n<p> Once the pipeline has been established, the file descriptors may be treated like descriptors to normal files.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*****************************************************************************</div><div class=\"line\"> Excerpt from &quot;Linux Programmer&apos;s Guide - Chapter 6&quot;</div><div class=\"line\"> (C)opyright 1994-1995, Scott Burkett</div><div class=\"line\"> *****************************************************************************</div><div class=\"line\"> MODULE: pipe.c</div><div class=\"line\"> *****************************************************************************/</div><div class=\"line\"></div><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;sys/types.h&gt;</div><div class=\"line\"></div><div class=\"line\">int main(void)</div><div class=\"line\">&#123;</div><div class=\"line\">        int     fd[2], nbytes;</div><div class=\"line\">        pid_t   childpid;</div><div class=\"line\">        char    string[] = &quot;Hello, world!\\n&quot;;</div><div class=\"line\">        char    readbuffer[80];</div><div class=\"line\"></div><div class=\"line\">        pipe(fd);</div><div class=\"line\"></div><div class=\"line\">        if((childpid = fork()) == -1)</div><div class=\"line\">        &#123;</div><div class=\"line\">                perror(&quot;fork&quot;);</div><div class=\"line\">                exit(1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if(childpid == 0)</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Child process closes up input side of pipe */</div><div class=\"line\">                close(fd[0]);</div><div class=\"line\"></div><div class=\"line\">                /* Send &quot;string&quot; through the output side of pipe */</div><div class=\"line\">                write(fd[1], string, (strlen(string)+1));</div><div class=\"line\">                exit(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else</div><div class=\"line\">        &#123;</div><div class=\"line\">                /* Parent process closes up output side of pipe */</div><div class=\"line\">                close(fd[1]);</div><div class=\"line\"></div><div class=\"line\">                /* Read in a string from the pipe */</div><div class=\"line\">                nbytes = read(fd[0], readbuffer, sizeof(readbuffer));</div><div class=\"line\">                printf(&quot;Received string: %s&quot;, readbuffer);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return(0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference:\"></a>Reference:</h3><ul>\n<li><a href=\"http://tldp.org/LDP/lpg/node11.html\">http://tldp.org/LDP/lpg/node11.html</a></li>\n<li><a href=\"https://upsilon.cc/~zack/teaching/1314/progsyst/cours-03-pipe.pdf\">https://upsilon.cc/~zack/teaching/1314/progsyst/cours-03-pipe.pdf</a></li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/CAP理论/CAP-Theorem-Example.png","slug":"CAP-Theorem-Example.png","post":"cj40xzpal0000inxxot9pjtef","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}